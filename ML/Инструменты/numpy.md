# Создание массивов
- np.arange() - 
- `np.linespace(start, stop, n)` - создать массив со значениями `[start, stop)` с длиной n. Последовательность будет выстроена равномерно.
- `np.random.normal()` - создаёт массив, значения которого распределены по гауссовому закону
	- `size`: tuple 
- `np.zeros(size)` - создаёт массив размером size, заполненный нулями
- `np.ones(size)` - создаёт массив, размером size, заполненный единицами
- `np.r_[array1, array2]` - выполняет конкатенацию вдоль первой оси. Грубо говоря, добавляет записи к строкам массива (если двумерный массив)
  Обрати внимание, здесь используется индексация []
  - `np.c_[array1, array2]` - выполняет конкатенацию вдоль второй оси - или по-простому - добавляет ещё один столбец.
  - `np.meshgrid(array1, array2)` - возвращает 2 двумерных массива, представляющих собой прямоугольную сетку с этими координатами:
    Координаты оси x дублируются `len(y)` раз, как и координаты оси y (только матрица транспонирована).
    Получается $X = \begin{bmatrix} x_1 & x_2 & ... & x_n \\ x_1 & x_2 & ... & x_n \\ ...\\ x_1 & x_2 & ... & x_n \end{bmatrix}$  $Y = \begin{bmatrix} y_m & y_m & ... & y_m \\ ... & ... & ... & ...\\ y_2 & y_2 & ... & y_2 \\ y_1 & y_1 & ... & y_1 \end{bmatrix}$. 
    ![[numpy.meshgrid.png|450]]![[numpy meshgrid.grid.png|200]]

# Операции над массивами
- `np.vectorize(func)` - создаёт объект `numpy.vectorize`, который можно использовать как функцию ($func(x)$), применяемую ко всем элементам переданного объекта $x$.
# Преобразование массивов
- matrix.ravel() - схлопывает исходную матрицу и возвращает одномерный массив 
  ```python
  x = np.array([[1, 2, 3], [4, 5, 6]])'
  np.ravel(x) => array([1, 2, 3, 4, 5, 6])
  ```
	- `matrix.reshape(-1)` - аналогично
