- `commit` - фиксирует изменения в репозитории в виде коммита
- `branch 
	- `[name]` -  создать ветку
	- `-f [branch_from] [branch_or_commit_to]` - **branch forcing** - перемещение ветки `[branch_from]` на то место, которое указывается в `[branch_or_commit_to]`
	  Пример: `branch -f main HEAD~3`
- `checkout [name]` - переключиться на ветку
	- `-b `- создать, если не создана
	- `^` - переключиться на родительский коммит (В качестве `[name]` можно указать **HEAD**. Тогда движение будет производиться относительно текущей ссылки *HEAD*) (
		- `checkout [hash]` - переключение на ссылку на коммит (**HEAD**). Весь хеш можно не записывать, а только первые 4 символа
	- `^^` - переключиться на коммит прародителя
	- `~<num>` - переключиться на num коммитов ранее
- `merge [имя ветки, откуда сливать изменения]` - провести слияние указанной ветки с той, на которой вызывается команда. В результате получается коммит-merge, которые имеет два родителя.
	- Чтобы сравнять версию ветки [name] с [main], можно сделать трюк: `git checkout [name]; git merge main`
- `rebase [main]` - копирование коммитов из текущей ветки в ветку [main]
	- `git checkout [main]; git rebase [name]` - обновление ветки [main] до новых обновлений после *rebase*
- `reset [ссылка_куда_переместиться]` - отменяет изменения, перенося ссылку на ветку *(на которой в данный момент работаем)* назад, переписывая историю (как будто некоторых коммитов вовсе и не было)
  **Работает только на локальных ветках, в локальных репозиториях!**
- `revert [ссылка_что_отменить]` - делает новый коммит, полностью противоположный тем изменениям, которые мы хотим отменить